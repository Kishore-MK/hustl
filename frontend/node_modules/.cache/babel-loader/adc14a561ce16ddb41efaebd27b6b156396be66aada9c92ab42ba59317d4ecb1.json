{"ast":null,"code":"import { Contract, SorobanRpc, TransactionBuilder, Networks, BASE_FEE, nativeToScVal, Address } from \"@stellar/stellar-sdk\";\nimport { userSignTransaction } from \"./freighter\";\nlet rpcUrl = \"https://soroban-testnet.stellar.org\";\nlet contractAddress = \"CDZSCIBEVLGIONHKCLIY7WAZFY63JPAJIZMTE7WDNJBFLD5YMXHE2SVL\";\nlet params = {\n  fee: BASE_FEE,\n  networkPassphrase: Networks.TESTNET\n};\nasync function contractInt(caller, functName, values) {\n  const provider = new SorobanRpc.Server(rpcUrl, {\n    allowHttp: true\n  });\n  const sourceAccount = await provider.getAccount(caller);\n  const contract = new Contract(contractAddress);\n  let buildTx;\n  if (values == null) {\n    buildTx = new TransactionBuilder(sourceAccount, params).addOperation(contract.call(functName)).setTimeout(30).build();\n  } else if (Array.isArray(values)) {\n    buildTx = new TransactionBuilder(sourceAccount, params).addOperation(contract.call(functName, ...values)).setTimeout(30).build();\n  } else {\n    buildTx = new TransactionBuilder(sourceAccount, params).addOperation(contract.call(functName, values)).setTimeout(30).build();\n  }\n  let _buildTx = await provider.prepareTransaction(buildTx);\n  let prepareTx = _buildTx.toXDR(); // pre-encoding (converting it to XDR format)\n\n  let signedTx = await userSignTransaction(prepareTx, \"TESTNET\", caller);\n  let tx = TransactionBuilder.fromXDR(signedTx, Networks.TESTNET);\n  try {\n    let sendTx = await provider.sendTransaction(tx).catch(function (err) {\n      console.error(\"Catch-1\", err);\n      return err;\n    });\n    if (sendTx.errorResult) {\n      throw new Error(\"Unable to submit transaction\");\n    }\n    if (sendTx.status === \"PENDING\") {\n      let txResponse = await provider.getTransaction(sendTx.hash);\n      //   we will continously checking the transaction status until it gets successfull added to the blockchain ledger or it gets rejected\n      while (txResponse.status === \"NOT_FOUND\") {\n        txResponse = await provider.getTransaction(sendTx.hash);\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      if (txResponse.status === \"SUCCESS\") {\n        let result = txResponse.returnValue;\n        return result;\n      }\n    }\n  } catch (err) {\n    console.log(\"Catch-2\", err);\n    return;\n  }\n}\n\n// function to interact with it's respective smart contract functions:\n\n// Working fine\nasync function createUser(caller) {\n  let address = caller;\n  let values = [address];\n  try {\n    var _user$_value;\n    const user = await contractInt(caller, \"createUser\", values);\n    let createdUser = user === null || user === void 0 ? void 0 : (_user$_value = user._value) === null || _user$_value === void 0 ? void 0 : _user$_value._value;\n    console.log(createdUser);\n    return createdUser;\n  } catch (error) {\n    console.log(\"Account already connected\");\n  }\n}\n\n// Working fine \nasync function upVote(caller, addr) {\n  let address = addr;\n  let values = address;\n  try {\n    const upvoted = await contractInt(caller, \"upVote\", values);\n    console.log(upvoted);\n  } catch (error) {\n    console.log(\"Try again!!\");\n  }\n}\nasync function downVote(caller, addr) {\n  let address = accountToScVal(addr);\n  let values = address;\n  try {\n    const downvoted = await contractInt(caller, \"downVote\", values);\n    console.log(downvoted);\n  } catch (error) {\n    console.log(\"Try again!!\");\n  }\n}\nasync function viewUser(caller, addr) {\n  let address = addr;\n  let values = address;\n  try {\n    const user = await contractInt(caller, \"viewUser\", values);\n    console.log(user);\n  } catch (error) {\n    console.log(\"Try again!!\");\n  }\n}\nexport { createUser, upVote, downVote, viewUser };","map":{"version":3,"names":["Contract","SorobanRpc","TransactionBuilder","Networks","BASE_FEE","nativeToScVal","Address","userSignTransaction","rpcUrl","contractAddress","params","fee","networkPassphrase","TESTNET","contractInt","caller","functName","values","provider","Server","allowHttp","sourceAccount","getAccount","contract","buildTx","addOperation","call","setTimeout","build","Array","isArray","_buildTx","prepareTransaction","prepareTx","toXDR","signedTx","tx","fromXDR","sendTx","sendTransaction","catch","err","console","error","errorResult","Error","status","txResponse","getTransaction","hash","Promise","resolve","result","returnValue","log","createUser","address","_user$_value","user","createdUser","_value","upVote","addr","upvoted","downVote","accountToScVal","downvoted","viewUser"],"sources":["/home/mk/code/stellar/frontend/src/components/contract.js"],"sourcesContent":["import {\n    Contract,\n    SorobanRpc,\n    TransactionBuilder,\n    Networks,\n    BASE_FEE,\n    nativeToScVal,\n    Address,\n  } from \"@stellar/stellar-sdk\";\n  import { userSignTransaction } from \"./freighter\";\n  \n  let rpcUrl = \"https://soroban-testnet.stellar.org\";\n  \n  let contractAddress =\n    \"CDZSCIBEVLGIONHKCLIY7WAZFY63JPAJIZMTE7WDNJBFLD5YMXHE2SVL\";\n  \n  let params = {\n    fee: BASE_FEE,\n    networkPassphrase: Networks.TESTNET,\n  };\n  \n  async function contractInt(caller, functName, values) {\n    const provider = new SorobanRpc.Server(rpcUrl, { allowHttp: true });\n    const sourceAccount = await provider.getAccount(caller);\n    const contract = new Contract(contractAddress);\n    let buildTx;\n  \n    if (values == null) {\n      buildTx = new TransactionBuilder(sourceAccount, params)\n        .addOperation(contract.call(functName))\n        .setTimeout(30)\n        .build();\n    } else if (Array.isArray(values)) {\n      buildTx = new TransactionBuilder(sourceAccount, params)\n        .addOperation(contract.call(functName, ...values))\n        .setTimeout(30)\n        .build();\n    } else {\n      buildTx = new TransactionBuilder(sourceAccount, params)\n        .addOperation(contract.call(functName, values))\n        .setTimeout(30)\n        .build();\n    \n      }\n\n      \n      \n    let _buildTx = await provider.prepareTransaction(buildTx);\n  \n    let prepareTx = _buildTx.toXDR(); // pre-encoding (converting it to XDR format)\n  \n    let signedTx = await userSignTransaction(prepareTx, \"TESTNET\", caller);\n  \n    let tx = TransactionBuilder.fromXDR(signedTx, Networks.TESTNET);\n  \n    try {\n      let sendTx = await provider.sendTransaction(tx).catch(function (err) {\n        console.error(\"Catch-1\", err);\n        return err;\n      });\n      if (sendTx.errorResult) {\n        throw new Error(\"Unable to submit transaction\");\n      }\n      if (sendTx.status === \"PENDING\") {\n        let txResponse = await provider.getTransaction(sendTx.hash);\n        //   we will continously checking the transaction status until it gets successfull added to the blockchain ledger or it gets rejected\n        while (txResponse.status === \"NOT_FOUND\") {\n          txResponse = await provider.getTransaction(sendTx.hash);\n          await new Promise((resolve) => setTimeout(resolve, 100));\n        }\n        if (txResponse.status === \"SUCCESS\") {\n          let result = txResponse.returnValue;\n          return result;\n        }\n      }\n    } catch (err) {\n      console.log(\"Catch-2\", err);\n      return;\n    }\n  }\n  \n  \n  // function to interact with it's respective smart contract functions:\n  \n  // Working fine\n  async function createUser(caller) {\n    let address=caller\n    let values = [address];\n  \n    try {\n      const user = await contractInt(caller, \"createUser\", values);\n      let createdUser = user?._value?._value;\n      console.log(createdUser);\n      return createdUser;\n    } catch (error) {\n      console.log(\"Account already connected\");\n    }\n  }\n  \n  \n  // Working fine \n  async function upVote(caller, addr) {\n    let address = addr;\n    let values = address;\n  \n    try {\n      const upvoted=await contractInt(caller, \"upVote\", values);\n      console.log(upvoted);\n    } catch (error) {\n      console.log(\"Try again!!\");\n    }\n  }\n  \n  async function downVote(caller, addr) {\n    let address = accountToScVal(addr);\n    let values = address;\n  \n    try {\n      const downvoted=await contractInt(caller, \"downVote\", values);\n      console.log(downvoted);\n    } catch (error) {\n      console.log(\"Try again!!\");\n    }\n  }\n  \n  async function viewUser(caller, addr) {\n    let address = addr;\n    let values = address;\n  \n    try {\n      const user=await contractInt(caller, \"viewUser\", values);\n      console.log(user);\n    } catch (error) {\n      console.log(\"Try again!!\");\n    }\n  }\n  \n \n  \n  \n  \n  export {\n    createUser,\n    upVote,\n    downVote,\n    viewUser\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}