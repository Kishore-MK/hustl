{"ast":null,"code":"import { Contract, SorobanRpc, TransactionBuilder, Networks, BASE_FEE, nativeToScVal, Address } from \"@stellar/stellar-sdk\";\nimport { userSignTransaction } from \"./freighter\";\nconst addressToScval = account => new Address(account).toScVal();\nlet rpcUrl = \"https://soroban-testnet.stellar.org\";\nlet contractAddress = \"CAJBGPTLMJ4VFTETMY5VPSA2C6IR4XK4S2EHU6O3GR5LFQIUWJSPBWOP\";\nlet params = {\n  fee: BASE_FEE,\n  networkPassphrase: Networks.TESTNET\n};\nasync function contractInt(caller, functName, values) {\n  const provider = new SorobanRpc.Server(rpcUrl, {\n    allowHttp: true\n  });\n  const sourceAccount = await provider.getAccount(caller);\n  const contract = new Contract(contractAddress);\n  let buildTx;\n  if (values == null) {\n    buildTx = new TransactionBuilder(sourceAccount, params).addOperation(contract.call(functName)).setTimeout(30).build();\n  } else if (Array.isArray(values)) {\n    buildTx = new TransactionBuilder(sourceAccount, params).addOperation(contract.call(functName, ...values)).setTimeout(30).build();\n  } else {\n    buildTx = new TransactionBuilder(sourceAccount, params).addOperation(contract.call(functName, values)).setTimeout(30).build();\n  }\n  let _buildTx = await provider.prepareTransaction(buildTx);\n  let prepareTx = _buildTx.toXDR(); // pre-encoding (converting it to XDR format)\n\n  let signedTx = await userSignTransaction(prepareTx, \"TESTNET\", caller);\n  let tx = TransactionBuilder.fromXDR(signedTx, Networks.TESTNET);\n  try {\n    let sendTx = await provider.sendTransaction(tx).catch(function (err) {\n      console.error(\"Catch-1\", err);\n      return err;\n    });\n    if (sendTx.errorResult) {\n      throw new Error(\"Unable to submit transaction\");\n    }\n    if (sendTx.status === \"PENDING\") {\n      let txResponse = await provider.getTransaction(sendTx.hash);\n      //   we will continously checking the transaction status until it gets successfull added to the blockchain ledger or it gets rejected\n      while (txResponse.status === \"NOT_FOUND\") {\n        txResponse = await provider.getTransaction(sendTx.hash);\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      if (txResponse.status === \"SUCCESS\") {\n        let result = txResponse.returnValue;\n        return result;\n      }\n    }\n  } catch (err) {\n    console.log(\"Catch-2\", err);\n    return;\n  }\n}\n\n// function to interact with it's respective smart contract functions:\n\n// Working fine\nasync function createUser(caller) {\n  var _user$_value$, _user$_value$$_atrrib, _user$_value$$_atrrib2, _user$_value$$_atrrib3, _user$_value$$_atrrib4;\n  console.log(caller);\n  let address = addressToScval(caller);\n  // try {\n  const user = await contractInt(caller, \"createUser\", address);\n  let createdUser = user === null || user === void 0 ? void 0 : (_user$_value$ = user._value[0]) === null || _user$_value$ === void 0 ? void 0 : (_user$_value$$_atrrib = _user$_value$._atrributes) === null || _user$_value$$_atrrib === void 0 ? void 0 : (_user$_value$$_atrrib2 = _user$_value$$_atrrib.val) === null || _user$_value$$_atrrib2 === void 0 ? void 0 : (_user$_value$$_atrrib3 = _user$_value$$_atrrib2._value) === null || _user$_value$$_atrrib3 === void 0 ? void 0 : (_user$_value$$_atrrib4 = _user$_value$$_atrrib3._value) === null || _user$_value$$_atrrib4 === void 0 ? void 0 : _user$_value$$_atrrib4.toString();\n  console.log(createdUser);\n  return createdUser;\n  // } catch (error) {\n  //   console.log(\"Account already connected\");\n  // }\n}\n\n// Working fine \nasync function upVote(caller, addr) {\n  let address = addr;\n  let values = address;\n  try {\n    const upvoted = await contractInt(caller, \"upVote\", values);\n    console.log(upvoted);\n  } catch (error) {\n    console.log(\"Try again!!\");\n  }\n}\nasync function downVote(caller, addr) {\n  let address = addr;\n  let values = address;\n  try {\n    const downvoted = await contractInt(caller, \"downVote\", values);\n    console.log(downvoted);\n  } catch (error) {\n    console.log(\"Try again!!\");\n  }\n}\nasync function viewUser(caller, addr) {\n  let address = addr;\n  let values = address;\n\n  // try {\n  const user = await contractInt(caller, \"viewUser\", values);\n  console.log(user);\n  // } catch (error) {\n  //   console.log(\"Try again!!\");\n  // }\n}\nexport { createUser, upVote, downVote, viewUser };","map":{"version":3,"names":["Contract","SorobanRpc","TransactionBuilder","Networks","BASE_FEE","nativeToScVal","Address","userSignTransaction","addressToScval","account","toScVal","rpcUrl","contractAddress","params","fee","networkPassphrase","TESTNET","contractInt","caller","functName","values","provider","Server","allowHttp","sourceAccount","getAccount","contract","buildTx","addOperation","call","setTimeout","build","Array","isArray","_buildTx","prepareTransaction","prepareTx","toXDR","signedTx","tx","fromXDR","sendTx","sendTransaction","catch","err","console","error","errorResult","Error","status","txResponse","getTransaction","hash","Promise","resolve","result","returnValue","log","createUser","_user$_value$","_user$_value$$_atrrib","_user$_value$$_atrrib2","_user$_value$$_atrrib3","_user$_value$$_atrrib4","address","user","createdUser","_value","_atrributes","val","toString","upVote","addr","upvoted","downVote","downvoted","viewUser"],"sources":["/home/mk/code/stellar/frontend/src/components/contract.js"],"sourcesContent":["import {\n    Contract,\n    SorobanRpc,\n    TransactionBuilder,\n    Networks,\n    BASE_FEE,\n    nativeToScVal,\n    Address,\n  } from \"@stellar/stellar-sdk\";\n  import { userSignTransaction } from \"./freighter\";\n  \n\n  const addressToScval = (account)=>new Address(account).toScVal();\n\n  let rpcUrl = \"https://soroban-testnet.stellar.org\";\n  \n  let contractAddress =\n    \"CAJBGPTLMJ4VFTETMY5VPSA2C6IR4XK4S2EHU6O3GR5LFQIUWJSPBWOP\";\n  \n  let params = {\n    fee: BASE_FEE,\n    networkPassphrase: Networks.TESTNET,\n  };\n  \n  async function contractInt(caller, functName, values) {\n    const provider = new SorobanRpc.Server(rpcUrl, { allowHttp: true });\n    const sourceAccount = await provider.getAccount(caller);\n    const contract = new Contract(contractAddress);\n    let buildTx;\n  \n    if (values == null) {\n      buildTx = new TransactionBuilder(sourceAccount, params)\n        .addOperation(contract.call(functName))\n        .setTimeout(30)\n        .build();\n    } else if (Array.isArray(values)) {\n      buildTx = new TransactionBuilder(sourceAccount, params)\n        .addOperation(contract.call(functName, ...values))\n        .setTimeout(30)\n        .build();\n    } else {\n      buildTx = new TransactionBuilder(sourceAccount, params)\n        .addOperation(contract.call(functName, values))\n        .setTimeout(30)\n        .build();\n    \n      }\n\n      \n      \n    let _buildTx = await provider.prepareTransaction(buildTx);\n  \n    let prepareTx = _buildTx.toXDR(); // pre-encoding (converting it to XDR format)\n  \n    let signedTx = await userSignTransaction(prepareTx, \"TESTNET\", caller);\n  \n    let tx = TransactionBuilder.fromXDR(signedTx, Networks.TESTNET);\n  \n    try {\n      let sendTx = await provider.sendTransaction(tx).catch(function (err) {\n        console.error(\"Catch-1\", err);\n        return err;\n      });\n      if (sendTx.errorResult) {\n        throw new Error(\"Unable to submit transaction\");\n      }\n      if (sendTx.status === \"PENDING\") {\n        let txResponse = await provider.getTransaction(sendTx.hash);\n        //   we will continously checking the transaction status until it gets successfull added to the blockchain ledger or it gets rejected\n        while (txResponse.status === \"NOT_FOUND\") {\n          txResponse = await provider.getTransaction(sendTx.hash);\n          await new Promise((resolve) => setTimeout(resolve, 100));\n        }\n        if (txResponse.status === \"SUCCESS\") {\n          let result = txResponse.returnValue;\n          return result;\n        }\n      }\n    } catch (err) {\n      console.log(\"Catch-2\", err);\n      return;\n    }\n  }\n  \n  \n  // function to interact with it's respective smart contract functions:\n  \n  // Working fine\n  async function createUser(caller) {\n    console.log(caller);\n    let address=addressToScval(caller)  \n    // try {\n      const user = await contractInt(caller, \"createUser\", address);\n      let createdUser = user?._value[0]?._atrributes?.val?._value?._value?.toString();\n      console.log(createdUser);\n      return createdUser;\n    // } catch (error) {\n    //   console.log(\"Account already connected\");\n    // }\n  }\n  \n  \n  // Working fine \n  async function upVote(caller, addr) {\n    let address = addr;\n    let values = address;\n  \n    try {\n      const upvoted=await contractInt(caller, \"upVote\", values);\n      console.log(upvoted);\n    } catch (error) {\n      console.log(\"Try again!!\");\n    }\n  }\n  \n  async function downVote(caller, addr) {\n    let address = addr;\n    let values = address;\n  \n    try {\n      const downvoted=await contractInt(caller, \"downVote\", values);\n      console.log(downvoted);\n    } catch (error) {\n      console.log(\"Try again!!\");\n    }\n  }\n  \n  async function viewUser(caller, addr) {\n    let address = addr;\n    let values = address;\n  \n    // try {\n      const user=await contractInt(caller, \"viewUser\", values);\n      console.log(user);\n    // } catch (error) {\n    //   console.log(\"Try again!!\");\n    // }\n  }\n  \n \n  \n  \n  \n  export {\n    createUser,\n    upVote,\n    downVote,\n    viewUser\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}